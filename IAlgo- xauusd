import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
import warnings
warnings.filterwarnings('ignore')
import time
import logging

import oandapyV20
import oandapyV20.endpoints.instruments as instruments
import oandapyV20.endpoints.orders as orders
import oandapyV20.endpoints.positions as positions
import oandapyV20.endpoints.accounts as accounts

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Model29AutoTradingStrategy:
    def __init__(self, initial_capital=10000, api_key=None, account_id=None, practice=True, trade_size=1000):
        self.initial_capital = initial_capital
        self.api_key = api_key
        self.account_id = account_id
        self.trade_size = trade_size  # Position size in units
        self.api_url = "https://api-fxpractice.oanda.com/v3" if practice else "https://api-fxtrade.oanda.com/v3"
        self.client = oandapyV20.API(access_token=self.api_key, environment="practice" if practice else "live")
        
        # Strategy parameters matching Pine Script
        self.entry_level = -1.5
        self.exit_level = 1.5
        self.rsi_oversold = 30
        self.rsi_overbought = 70
        self.rsi_length = 14
        self.rsi_smoothing = 5
        self.spread_lookback = 5
        
        # State tracking
        self.prev_z = None
        self.current_position = 0
        self.last_trade_time = None
        self.trades_log = []
        
    def _fetch_instrument(self, instrument, count=100, granularity="M5"):
        """Fetch recent candles for a given instrument"""
        params = {
            "count": count,
            "granularity": granularity,
            "price": "M"  # Midpoint prices
        }
        r = instruments.InstrumentsCandles(instrument=instrument, params=params)
        self.client.request(r)
        
        candles = r.response.get("candles", [])
        df = pd.DataFrame([
            {
                "time": pd.to_datetime(c["time"]),
                "open": float(c["mid"]["o"]),
                "high": float(c["mid"]["h"]),
                "low": float(c["mid"]["l"]),
                "close": float(c["mid"]["c"])
            }
            for c in candles if c["complete"]
        ])
        
        if not df.empty:
            df.set_index("time", inplace=True)
        return df

    def fetch_current_data(self):
        """Fetch current market data and calculate indicators"""
        try:
            logger.info("Fetching current market data...")
            
            # Fetch data for all required instruments
            xauaud_data = self._fetch_instrument("XAU_AUD", count=5000, granularity="M5")
            usdjpy_data = self._fetch_instrument("USD_JPY", count=5000, granularity="M5")
            main_data = self._fetch_instrument("XAU_AUD", count=5000, granularity="H1")  # For RSI
            
            if xauaud_data.empty or usdjpy_data.empty or main_data.empty:
                logger.error("Failed to fetch required data")
                return None
                
            # Align data by reindexing to common timeframe
            combined_index = xauaud_data.index.intersection(usdjpy_data.index)
            if len(combined_index) < 30:
                logger.error("Insufficient aligned data points")
                return None
                
            df = pd.DataFrame({
                "xauaud_close": xauaud_data.loc[combined_index, "close"],
                "usdjpy_close": usdjpy_data.loc[combined_index, "close"],
            })
            
            # Calculate log values (matching Pine Script)
            df["btc"] = np.log(df["xauaud_close"])
            df["doge"] = np.log(df["usdjpy_close"])
            
            # Calculate spread and z-score
            df["spread"] = df["btc"] - df["doge"]
            df["spread_ma"] = df["spread"].rolling(window=self.spread_lookback).mean()
            df["spread_std"] = df["spread"].rolling(window=self.spread_lookback).std()
            df["z_score"] = (df["spread"] - df["spread_ma"]) / df["spread_std"]
            
            # Calculate RSI from 30-minute data and smooth it
            df["rsi_raw"] = self._calculate_rsi(main_data["close"], self.rsi_length)
            df["rsi_smoothed"] = df["rsi_raw"].rolling(window=self.rsi_smoothing).mean()
            
            # Remove NaN values
            df = df.dropna()
            
            logger.info(f"Data processed: {len(df)} valid rows")
            return df
            
        except Exception as e:
            logger.error(f"Error fetching data: {e}")
            return None

    def _calculate_rsi(self, prices, length=14):
        """Calculate RSI indicator"""
        if len(prices) < length + 1:
            return pd.Series([np.nan] * len(prices), index=prices.index)
            
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=length).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=length).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def get_current_position(self, instrument="XAU_AUD"):
        """Get current position for the instrument"""
        try:
            r = positions.OpenPositions(accountID=self.account_id)
            self.client.request(r)
            
            for position in r.response.get("positions", []):
                if position["instrument"] == instrument:
                    long_units = float(position["long"]["units"])
                    short_units = float(position["short"]["units"])
                    return long_units + short_units
            return 0
            
        except Exception as e:
            logger.error(f"Error getting position: {e}")
            return 0

    def place_market_order(self, instrument, units, order_type="MARKET"):
        """Place a market order"""
        try:
            order_data = {
                "order": {
                    "type": order_type,
                    "instrument": instrument,
                    "units": str(int(units)),
                    "timeInForce": "FOK",  # Fill or Kill
                    "positionFill": "DEFAULT"
                }
            }
            
            r = orders.OrderCreate(accountID=self.account_id, data=order_data)
            self.client.request(r)
            
            logger.info(f"Order placed: {units} units of {instrument}")
            return r.response
            
        except Exception as e:
            logger.error(f"Error placing order: {e}")
            return None

    def close_position(self, instrument="XAU_AUD"):
        """Close current position"""
        try:
            current_pos = self.get_current_position(instrument)
            if abs(current_pos) > 0:
                # Close by placing opposite order
                close_units = -current_pos
                return self.place_market_order(instrument, close_units)
            return None
            
        except Exception as e:
            logger.error(f"Error closing position: {e}")
            return None

    def check_trading_conditions(self, df):
        """Check for entry and exit conditions based on Pine Script logic"""
        if len(df) < 2:
            return False, False
            
        # Get current and previous values
        current_z = df["z_score"].iloc[-1]
        current_rsi = df["rsi_smoothed"].iloc[-1]
        
        # Use stored prev_z or calculate from data
        if self.prev_z is None and len(df) >= 2:
            self.prev_z = df["z_score"].iloc[-2]
            
        if self.prev_z is None or pd.isna(current_z) or pd.isna(current_rsi):
            return False, False
            
        # Entry condition: prev_z >= -1.5 and current_z < -1.5 and RSI < 30
        long_condition = (self.prev_z >= self.entry_level and 
                         current_z < self.entry_level and 
                         current_rsi < self.rsi_oversold)
        
        # Exit condition: prev_z <= 1.5 and current_z > 1.5 and RSI > 70
        exit_condition = (self.prev_z <= self.exit_level and 
                         current_z > self.exit_level and 
                         current_rsi > self.rsi_overbought)
        
        # Update prev_z for next iteration
        self.prev_z = current_z
        
        logger.info(f"Z-Score: {current_z:.4f} (prev: {self.prev_z:.4f}), RSI: {current_rsi:.2f}")
        logger.info(f"Long condition: {long_condition}, Exit condition: {exit_condition}")
        
        return long_condition, exit_condition

    def execute_trading_logic(self, instrument="USD_JPY"):
        """Main trading logic execution"""
        try:
            # Fetch current data
            df = self.fetch_current_data()
            if df is None or len(df) < 30:  # Need minimum data for calculations
                logger.warning("Insufficient data for trading decisions")
                return
                
            # Get current position
            current_position = self.get_current_position(instrument)
            self.current_position = current_position
            
            # Check trading conditions
            long_condition, exit_condition = self.check_trading_conditions(df)
            
            # Execute trades based on conditions
            if long_condition and abs(current_position) < 100:  # Not already in position
                logger.info("ENTRY SIGNAL: Opening long position")
                order_response = self.place_market_order(instrument, self.trade_size)
                if order_response:
                    self.trades_log.append({
                        "timestamp": datetime.now(),
                        "action": "ENTRY",
                        "z_score": df["z_score"].iloc[-1],
                        "rsi": df["rsi_smoothed"].iloc[-1],
                        "units": self.trade_size
                    })
                    
            elif exit_condition and current_position > 0:  # In long position
                logger.info("EXIT SIGNAL: Closing long position")
                order_response = self.close_position(instrument)
                if order_response:
                    self.trades_log.append({
                        "timestamp": datetime.now(),
                        "action": "EXIT",
                        "z_score": df["z_score"].iloc[-1],
                        "rsi": df["rsi_smoothed"].iloc[-1],
                        "units": -current_position
                    })
                    
        except Exception as e:
            logger.error(f"Error in trading logic: {e}")

    def get_account_summary(self):
        """Get account balance and open positions"""
        try:
            r = accounts.AccountSummary(accountID=self.account_id)
            self.client.request(r)
            
            balance = float(r.response["account"]["balance"])
            unrealized_pl = float(r.response["account"]["unrealizedPL"])
            
            logger.info(f"Account Balance: ${balance:.2f}, Unrealized P&L: ${unrealized_pl:.2f}")
            return balance, unrealized_pl
            
        except Exception as e:
            logger.error(f"Error getting account summary: {e}")
            return None, None

    def run_live_trading(self, check_interval=300, max_iterations=None):
        """
        Run live trading strategy
        
        Args:
            check_interval: Seconds between strategy checks (default 5 minutes)
            max_iterations: Maximum number of iterations (None for unlimited)
        """
        logger.info("Starting live trading strategy...")
        logger.info(f"Check interval: {check_interval} seconds")
        
        iteration = 0
        
        try:
            while True:
                if max_iterations and iteration >= max_iterations:
                    logger.info("Maximum iterations reached, stopping...")
                    break
                    
                iteration += 1
                logger.info(f"\n=== Trading Check #{iteration} ===")
                
                # Get account status
                balance, unrealized_pl = self.get_account_summary()
                
                # Execute trading logic
                self.execute_trading_logic()
                
                # Print recent trades
                if self.trades_log:
                    logger.info("Recent trades:")
                    for trade in self.trades_log[-3:]:  # Show last 3 trades
                        logger.info(f"  {trade['timestamp']}: {trade['action']} - Z:{trade['z_score']:.4f}, RSI:{trade['rsi']:.2f}")
                
                # Wait for next check
                logger.info(f"Waiting {check_interval} seconds until next check...")
                time.sleep(check_interval)
                
        except KeyboardInterrupt:
            logger.info("Trading stopped by user")
        except Exception as e:
            logger.error(f"Error in live trading: {e}")
        finally:
            logger.info("Trading strategy stopped")

    def backtest_strategy(self, start_date="2021-01-01", end_date=None):
        """Backtest the strategy on historical data"""
        logger.info("Running backtest...")
        
        df = self.fetch_data(start_date, end_date)
        if df is None:
            return None
            
        # Calculate indicators
        df = self.calculate_indicators(df)
        
        # Simulate trading
        equity = self.initial_capital
        position = 0
        entry_price = 0
        trades = []
        equity_curve = [equity]
        
        prev_z = None
        
        for i in range(30, len(df)):  # Start after sufficient data for indicators
            current_z = df["z_score"].iloc[i]
            current_rsi = df["rsi_smoothed"].iloc[i]
            current_price = df["usdjpy_close"].iloc[i]
            
            if prev_z is None:
                prev_z = df["z_score"].iloc[i-1] if i > 0 else None
                continue
                
            if pd.isna(current_z) or pd.isna(current_rsi) or pd.isna(prev_z):
                prev_z = current_z
                continue
                
            # Entry condition
            long_condition = (prev_z >= self.entry_level and 
                            current_z < self.entry_level and 
                            current_rsi < self.rsi_oversold)
            
            # Exit condition  
            exit_condition = (prev_z <= self.exit_level and 
                            current_z > self.exit_level and 
                            current_rsi > self.rsi_overbought)
            
            # Execute trades
            if long_condition and position == 0:
                position = self.trade_size / current_price  # Convert to position size
                entry_price = current_price
                trades.append({
                    "date": df.index[i],
                    "action": "ENTRY",
                    "price": current_price,
                    "z_score": current_z,
                    "rsi": current_rsi
                })
                logger.info(f"ENTRY at {df.index[i]}: Z={current_z:.4f}, RSI={current_rsi:.2f}")
                
            elif exit_condition and position > 0:
                # Calculate P&L
                pnl = position * (current_price - entry_price)
                equity += pnl
                trades.append({
                    "date": df.index[i],
                    "action": "EXIT",
                    "price": current_price,
                    "z_score": current_z,
                    "rsi": current_rsi,
                    "pnl": pnl
                })
                logger.info(f"EXIT at {df.index[i]}: Z={current_z:.4f}, RSI={current_rsi:.2f}, P&L={pnl:.2f}")
                position = 0
                
            equity_curve.append(equity)
            prev_z = current_z
            
        return {
            "trades": trades,
            "equity_curve": equity_curve,
            "final_equity": equity,
            "total_return": (equity - self.initial_capital) / self.initial_capital * 100
        }

    def calculate_indicators(self, df):
        """Calculate all required indicators matching Pine Script"""
        # Log values for BTC and DOGE proxies
        df["btc"] = np.log(df["xauaud_close"])
        df["doge"] = np.log(df["usdjpy_close"])
        
        # Calculate spread and z-score
        df["spread"] = df["btc"] - df["doge"]
        df["spread_ma"] = df["spread"].rolling(window=self.spread_lookback).mean()
        df["spread_std"] = df["spread"].rolling(window=self.spread_lookback).std()
        df["z_score"] = (df["spread"] - df["spread_ma"]) / df["spread_std"]
        
        # Calculate RSI and smooth it
        df["rsi_raw"] = self._calculate_rsi(df["usdjpy_close"], self.rsi_length)
        df["rsi_smoothed"] = df["rsi_raw"].rolling(window=self.rsi_smoothing).mean()
        
        return df

    def fetch_data(self, start_date="2021-01-01", end_date=None):
        """Fetch historical data for backtesting"""
        if end_date is None:
            end_date = datetime.utcnow()
        else:
            end_date = pd.to_datetime(end_date)
            
        start_date = pd.to_datetime(start_date)
        
        logger.info("Fetching historical data for backtesting...")
        
        # For backtesting, we need more data points
        days_diff = (end_date - start_date).days
        count = min(5000, max(500, days_diff * 24 // 5))  # Estimate based on 5-minute candles
        
        # Fetch data
        xauaud = self._fetch_instrument("XAU_AUD", count=count, granularity="M5")
        usdjpy = self._fetch_instrument("USD_JPY", count=count, granularity="M5")
        
        if xauaud.empty or usdjpy.empty:
            logger.error("Failed to fetch historical data")
            return None
            
        # Combine data
        df = pd.DataFrame({
            "xauaud_close": xauaud["close"],
            "usdjpy_close": usdjpy["close"],
        })
        
        df = df.fillna(method="ffill").dropna()
        
        logger.info(f"Historical data fetched: {len(df)} rows from {df.index[0]} to {df.index[-1]}")
        return df

    def plot_results(self, backtest_results, df):
        """Plot backtest results"""
        if not backtest_results or df is None:
            return
            
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        
        # Z-Score plot
        ax1.plot(df.index, df["z_score"], label="Z-Score", color="orange")
        ax1.axhline(y=self.entry_level, color="green", linestyle="--", label=f"Entry Level ({self.entry_level})")
        ax1.axhline(y=self.exit_level, color="red", linestyle="--", label=f"Exit Level ({self.exit_level})")
        ax1.axhline(y=0, color="gray", alpha=0.5)
        ax1.set_title("Z-Score")
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # RSI plot
        ax2.plot(df.index, df["rsi_smoothed"], label="RSI Smoothed", color="blue")
        ax2.axhline(y=self.rsi_oversold, color="green", linestyle=":", label=f"Oversold ({self.rsi_oversold})")
        ax2.axhline(y=self.rsi_overbought, color="red", linestyle=":", label=f"Overbought ({self.rsi_overbought})")
        ax2.set_title("RSI Smoothed")
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # Price chart with trade markers
        ax3.plot(df.index, df["usdjpy_close"], label="USD/JPY", alpha=0.7)
        
        for trade in backtest_results["trades"]:
            if trade["action"] == "ENTRY":
                ax3.scatter(trade["date"], trade["price"], color="green", marker="^", s=100, label="Entry" if "Entry" not in [l.get_label() for l in ax3.get_children()] else "")
            elif trade["action"] == "EXIT":
                ax3.scatter(trade["date"], trade["price"], color="red", marker="v", s=100, label="Exit" if "Exit" not in [l.get_label() for l in ax3.get_children()] else "")
        
        ax3.set_title("USD/JPY with Trade Signals")
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # Equity curve
        ax4.plot(backtest_results["equity_curve"], color="purple")
        ax4.set_title(f"Equity Curve - Total Return: {backtest_results['total_return']:.2f}%")
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()

    def print_trade_summary(self, backtest_results):
        """Print summary of backtest results"""
        if not backtest_results:
            return
            
        trades = backtest_results["trades"]
        
        print("\n" + "="*50)
        print("BACKTEST SUMMARY")
        print("="*50)
        print(f"Initial Capital: ${self.initial_capital:,.2f}")
        print(f"Final Equity: ${backtest_results['final_equity']:,.2f}")
        print(f"Total Return: {backtest_results['total_return']:.2f}%")
        print(f"Total Trades: {len([t for t in trades if t['action'] == 'ENTRY'])}")
        
        # Calculate trade statistics
        entry_trades = [t for t in trades if t["action"] == "ENTRY"]
        exit_trades = [t for t in trades if t["action"] == "EXIT" and "pnl" in t]
        
        if exit_trades:
            pnls = [t["pnl"] for t in exit_trades]
            winning_trades = [p for p in pnls if p > 0]
            losing_trades = [p for p in pnls if p < 0]
            
            print(f"Completed Trades: {len(exit_trades)}")
            print(f"Winning Trades: {len(winning_trades)} ({len(winning_trades)/len(exit_trades)*100:.1f}%)")
            print(f"Average Win: ${np.mean(winning_trades):.2f}" if winning_trades else "Average Win: N/A")
            print(f"Average Loss: ${np.mean(losing_trades):.2f}" if losing_trades else "Average Loss: N/A")
            print(f"Best Trade: ${max(pnls):.2f}")
            print(f"Worst Trade: ${min(pnls):.2f}")
        
        print("\nRecent Trades:")
        for trade in trades[-5:]:  # Show last 5 trades
            action_str = f"{trade['action']:<5}"
            if 'pnl' in trade:
                print(f"  {trade['date']} | {action_str} | Z:{trade['z_score']:7.4f} | RSI:{trade['rsi']:6.2f} | P&L:${trade['pnl']:8.2f}")
            else:
                print(f"  {trade['date']} | {action_str} | Z:{trade['z_score']:7.4f} | RSI:{trade['rsi']:6.2f}")


def main():
    """Main execution function"""
    # IMPORTANT: Replace with your actual OANDA credentials
    API_KEY = "ed8532dc1f105e66db76dbd2b13d0fef-069204ad50e2ba47935775d37816d3bc"
    ACCOUNT_ID = "101-011-36232014-001"
    
    # Initialize strategy
    strategy = Model29AutoTradingStrategy(
        initial_capital=10000,
        api_key=API_KEY,
        account_id=ACCOUNT_ID,
        practice=True,  # Set to False for live trading
        trade_size=10000  # Position size in units
    )
    
    print("Model 29 Auto Trading Strategy")
    print("1. Run Backtest")
    print("2. Start Live Trading")
    print("3. Check Account Status")
    
    choice = input("Select option (1-3): ").strip()
    
    if choice == "1":
        # Run backtest
        logger.info("Running backtest...")
        df = strategy.fetch_data(start_date="2010-01-01")
        if df is not None:
            backtest_results = strategy.backtest_strategy()
            strategy.print_trade_summary(backtest_results)
            # Uncomment to show plots
            strategy.plot_results(backtest_results, df)
        
    elif choice == "2":
        # Start live trading
        check_interval = int(input("Enter check interval in seconds (default 300): ") or "300")
        max_iterations = input("Enter max iterations (press Enter for unlimited): ").strip()
        max_iterations = int(max_iterations) if max_iterations else None
        
        logger.info("Starting live trading...")
        logger.info("Press Ctrl+C to stop trading")
        
        strategy.run_live_trading(check_interval=check_interval, max_iterations=max_iterations)
        
    elif choice == "3":
        # Check account status
        balance, unrealized_pl = strategy.get_account_summary()
        current_pos = strategy.get_current_position("XAU_AUD")
        print(f"\nAccount Balance: ${balance:.2f}")
        print(f"Unrealized P&L: ${unrealized_pl:.2f}")
        print(f"Current USD/JPY Position: {current_pos} units")
        
        # Fetch and display current indicators
        df = strategy.fetch_current_data()
        if df is not None and len(df) > 0:
            print(f"\nCurrent Indicators:")
            print(f"Z-Score: {df['z_score'].iloc[-1]:.4f}")
            print(f"RSI: {df['rsi_smoothed'].iloc[-1]:.2f}")
            print(f"Spread: {df['spread'].iloc[-1]:.6f}")
    
    else:
        print("Invalid choice")

if __name__ == "__main__":
    main()
